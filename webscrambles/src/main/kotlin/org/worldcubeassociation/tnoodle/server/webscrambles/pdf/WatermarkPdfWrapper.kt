package org.worldcubeassociation.tnoodle.server.webscrambles.pdf

import com.itextpdf.text.*
import com.itextpdf.text.pdf.ColumnText
import com.itextpdf.text.pdf.PdfGState
import com.itextpdf.text.pdf.PdfReader
import com.itextpdf.text.pdf.PdfWriter
import org.worldcubeassociation.tnoodle.server.webscrambles.pdf.util.FontUtil
import java.io.ByteArrayOutputStream
import java.time.LocalDate
import kotlin.math.PI
import kotlin.math.atan

class WatermarkPdfWrapper(
    private val original: PdfContent,
    private val creationTitle: String,
    private val creationDate: LocalDate,
    private val versionTag: String,
    private val globalTitle: String?,
    private val watermark: String? = null
) : BasePdfSheet<PdfWriter>() {
    override fun openDocument() = Document(PAGE_SIZE, 0f, 0f, 75f, 75f)

    override fun Document.getWriter(bytes: ByteArrayOutputStream): PdfWriter = PdfWriter.getInstance(this, bytes)

    override fun PdfWriter.writeContents(document: Document) {
        val cb = directContent
        val pr = PdfReader(original.render())

        for (pageN in 1..pr.numberOfPages) {
            document.newPage()

            // Frontend watermark
            if (watermark != null) {
                val transparentState = PdfGState().apply {
                    setFillOpacity(WATERMARK_OPACITY)
                    setStrokeOpacity(WATERMARK_OPACITY)
                }

                cb.saveState()
                cb.setGState(transparentState)

                val diagRotation = atan(PAGE_SIZE.height / PAGE_SIZE.width) * (180f / PI)

                ColumnText.showTextAligned(cb,
                    Element.ALIGN_CENTER, Phrase(watermark, Font(FontUtil.NOTO_SANS_FONT, 72f, Font.BOLD)),
                    (PAGE_SIZE.left + PAGE_SIZE.right) / 2, (PAGE_SIZE.top + PAGE_SIZE.bottom) / 2, diagRotation.toFloat())

                cb.restoreState()
            }

            // add the imported page *after* potential watermarks
            // so the watermark stays in the background
            val page = getImportedPage(pr, pageN)
            cb.addTemplate(page, 0f, 0f)

            val rect = pr.getBoxSize(pageN, "art")
            val headerHeight = PAGE_SIZE.height / HEADER_AND_FOOTER_HEIGHT_RATIO

            val headerRect = Rectangle(PAGE_SIZE.left, PAGE_SIZE.top - headerHeight, PAGE_SIZE.right, PAGE_SIZE.top)

            // Header
            ColumnText.showTextAligned(cb,
                Element.ALIGN_LEFT, Phrase(creationDate.toString()),
                rect.left, headerRect.bottom, 0f)

            ColumnText.showTextAligned(cb,
                Element.ALIGN_CENTER, Phrase(globalTitle),
                (PAGE_SIZE.left + PAGE_SIZE.right) / 2, headerRect.bottom + headerRect.height / 4, 0f)

            ColumnText.showTextAligned(cb,
                Element.ALIGN_CENTER, Phrase(creationTitle),
                (PAGE_SIZE.left + PAGE_SIZE.right) / 2, headerRect.bottom, 0f)

            if (pr.numberOfPages > 1) {
                ColumnText.showTextAligned(cb,
                    Element.ALIGN_RIGHT, Phrase(pageN.toString() + "/" + pr.numberOfPages),
                    rect.right, headerRect.bottom, 0f)
            }

            // Footer
            val footerRect = Rectangle(PAGE_SIZE.left, PAGE_SIZE.bottom, PAGE_SIZE.right, PAGE_SIZE.bottom + headerHeight)
            val generatedBy = "Generated by $versionTag"

            ColumnText.showTextAligned(cb,
                Element.ALIGN_CENTER, Phrase(generatedBy),
                (PAGE_SIZE.left + PAGE_SIZE.right) / 2, footerRect.top - footerRect.height / 4, 0f)
        }
    }

    companion object {
        const val HEADER_AND_FOOTER_HEIGHT_RATIO = 12
        const val WATERMARK_OPACITY = 0.1f
    }
}
